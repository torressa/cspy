<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>cspy: labelling::Label Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">cspy
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacelabelling.html">labelling</a></li><li class="navelem"><a class="el" href="classlabelling_1_1Label.html">Label</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classlabelling_1_1Label-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">labelling::Label Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="labelling_8h_source.html">labelling.h</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for labelling::Label:</div>
<div class="dyncontent">
<div class="center"><img src="classlabelling_1_1Label__coll__graph.png" border="0" usemap="#labelling_1_1Label_coll__map" alt="Collaboration graph"/></div>
<!-- MAP 0 -->
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a3728b76c8b32589e04ecaac821f11733"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlabelling_1_1Label.html#a3728b76c8b32589e04ecaac821f11733">Label</a> ()</td></tr>
<tr class="memdesc:a3728b76c8b32589e04ecaac821f11733"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dummy constructor.  <a href="#a3728b76c8b32589e04ecaac821f11733">More...</a><br /></td></tr>
<tr class="separator:a3728b76c8b32589e04ecaac821f11733"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6861a92f1825ed3bb9ea46515cdf1d16"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlabelling_1_1Label.html#a6861a92f1825ed3bb9ea46515cdf1d16">Label</a> (const double &amp;weight_in, const <a class="el" href="structbidirectional_1_1Vertex.html">bidirectional::Vertex</a> &amp;vertex_in, const std::vector&lt; double &gt; &amp;resource_consumption_in, const std::vector&lt; int &gt; &amp;partial_path_in, <a class="el" href="classbidirectional_1_1Params.html">bidirectional::Params</a> *params)</td></tr>
<tr class="memdesc:a6861a92f1825ed3bb9ea46515cdf1d16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="#a6861a92f1825ed3bb9ea46515cdf1d16">More...</a><br /></td></tr>
<tr class="separator:a6861a92f1825ed3bb9ea46515cdf1d16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a255f1384159b9748980f824eb1ddb5f8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlabelling_1_1Label.html#a255f1384159b9748980f824eb1ddb5f8">Label</a> (const double &amp;weight_in, const <a class="el" href="structbidirectional_1_1Vertex.html">bidirectional::Vertex</a> &amp;vertex_in, const std::vector&lt; double &gt; &amp;resource_consumption_in, const std::vector&lt; int &gt; &amp;partial_path_in, <a class="el" href="classbidirectional_1_1Params.html">bidirectional::Params</a> *params, const double &amp;phi_in)</td></tr>
<tr class="separator:a255f1384159b9748980f824eb1ddb5f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72d8b0e24b8dbacc1ecb40b3c32265e2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlabelling_1_1Label.html#a72d8b0e24b8dbacc1ecb40b3c32265e2">~Label</a> ()</td></tr>
<tr class="memdesc:a72d8b0e24b8dbacc1ecb40b3c32265e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">default destructor  <a href="#a72d8b0e24b8dbacc1ecb40b3c32265e2">More...</a><br /></td></tr>
<tr class="separator:a72d8b0e24b8dbacc1ecb40b3c32265e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23f7e5da2fb22dca07977aad9bfa9ad3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlabelling_1_1Label.html">Label</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlabelling_1_1Label.html#a23f7e5da2fb22dca07977aad9bfa9ad3">extend</a> (const <a class="el" href="structbidirectional_1_1AdjVertex.html">bidirectional::AdjVertex</a> &amp;adjacent_vertex, const <a class="el" href="namespacebidirectional.html#a4cbe6f0bfbd3629c2cd44c98014aed70">bidirectional::Directions</a> &amp;direction, const std::vector&lt; double &gt; &amp;max_res={}, const std::vector&lt; double &gt; &amp;min_res={})</td></tr>
<tr class="separator:a23f7e5da2fb22dca07977aad9bfa9ad3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5afbf2f5d2c6f208283021186783883"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlabelling_1_1Label.html#ad5afbf2f5d2c6f208283021186783883">checkDominance</a> (const <a class="el" href="classlabelling_1_1Label.html">Label</a> &amp;other, const <a class="el" href="namespacebidirectional.html#a4cbe6f0bfbd3629c2cd44c98014aed70">bidirectional::Directions</a> &amp;direction) const</td></tr>
<tr class="separator:ad5afbf2f5d2c6f208283021186783883"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f59b4a2818a4b0096080cd5f830b73d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlabelling_1_1Label.html#a3f59b4a2818a4b0096080cd5f830b73d">fullDominance</a> (const <a class="el" href="classlabelling_1_1Label.html">Label</a> &amp;other, const <a class="el" href="namespacebidirectional.html#a4cbe6f0bfbd3629c2cd44c98014aed70">bidirectional::Directions</a> &amp;direction) const</td></tr>
<tr class="separator:a3f59b4a2818a4b0096080cd5f830b73d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc3068c1147414d77f0f7696b4687e69"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlabelling_1_1Label.html#adc3068c1147414d77f0f7696b4687e69">checkFeasibility</a> (const std::vector&lt; double &gt; &amp;max_res, const std::vector&lt; double &gt; &amp;min_res, const bool &amp;soft=false) const</td></tr>
<tr class="separator:adc3068c1147414d77f0f7696b4687e69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72d0d91c2d99edbcdc36aa157586cf00"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlabelling_1_1Label.html#a72d0d91c2d99edbcdc36aa157586cf00">checkThreshold</a> (const double &amp;threshold) const</td></tr>
<tr class="memdesc:a72d0d91c2d99edbcdc36aa157586cf00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if weight is under the input threshold.  <a href="#a72d0d91c2d99edbcdc36aa157586cf00">More...</a><br /></td></tr>
<tr class="separator:a72d0d91c2d99edbcdc36aa157586cf00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e4957ff69cf08cfdc743df10d50d3c7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlabelling_1_1Label.html#a0e4957ff69cf08cfdc743df10d50d3c7">checkStPath</a> (const int &amp;source_id, const int &amp;sink_id) const</td></tr>
<tr class="separator:a0e4957ff69cf08cfdc743df10d50d3c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a496b8a76fd2fe06265b1acc1a508b4ca"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlabelling_1_1Label.html#a496b8a76fd2fe06265b1acc1a508b4ca">checkPathExtension</a> (const int &amp;user_id) const</td></tr>
<tr class="memdesc:a496b8a76fd2fe06265b1acc1a508b4ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true is the partial path extension is OK.  <a href="#a496b8a76fd2fe06265b1acc1a508b4ca">More...</a><br /></td></tr>
<tr class="separator:a496b8a76fd2fe06265b1acc1a508b4ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c8dc87a89577d00ccf86251867ec76a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlabelling_1_1Label.html#a5c8dc87a89577d00ccf86251867ec76a">checkSameFeasibleExtensionTwoCycleSimple</a> (const <a class="el" href="classlabelling_1_1Label.html">Label</a> &amp;other) const</td></tr>
<tr class="separator:a5c8dc87a89577d00ccf86251867ec76a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a333b6fc9dba864b3df2cdf530a055aa7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlabelling_1_1Label.html#a333b6fc9dba864b3df2cdf530a055aa7">checkSameFeasibleExtensionElementary</a> (const <a class="el" href="classlabelling_1_1Label.html">Label</a> &amp;other) const</td></tr>
<tr class="separator:a333b6fc9dba864b3df2cdf530a055aa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02179d540444a13aa7cc3355d0a461b8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlabelling_1_1Label.html#a02179d540444a13aa7cc3355d0a461b8">checkSameFeasibleExtension</a> (const <a class="el" href="classlabelling_1_1Label.html">Label</a> &amp;other) const</td></tr>
<tr class="separator:a02179d540444a13aa7cc3355d0a461b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afffea46e29dc7074edd10470c5dfeb87"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlabelling_1_1Label.html#afffea46e29dc7074edd10470c5dfeb87">setPhi</a> (const double &amp;phi_in)</td></tr>
<tr class="memdesc:afffea46e29dc7074edd10470c5dfeb87"><td class="mdescLeft">&#160;</td><td class="mdescRight">set phi attribute for merged labels from Righini and Salani (2006)  <a href="#afffea46e29dc7074edd10470c5dfeb87">More...</a><br /></td></tr>
<tr class="separator:afffea46e29dc7074edd10470c5dfeb87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a676337cc2e66ddaba088c736b9220651"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlabelling_1_1Label.html#a676337cc2e66ddaba088c736b9220651">getPredecessorId</a> () const</td></tr>
<tr class="separator:a676337cc2e66ddaba088c736b9220651"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc93c3a59a853bc559bb63e8df1ae67e"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlabelling_1_1Label.html#adc93c3a59a853bc559bb63e8df1ae67e">getString</a> () const</td></tr>
<tr class="separator:adc93c3a59a853bc559bb63e8df1ae67e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96fec70e1378988bb3d01f3aee8ab676"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlabelling_1_1Label.html">Label</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlabelling_1_1Label.html#a96fec70e1378988bb3d01f3aee8ab676">operator=</a> (const <a class="el" href="classlabelling_1_1Label.html">Label</a> &amp;other)=default</td></tr>
<tr class="separator:a96fec70e1378988bb3d01f3aee8ab676"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a478f34a67528586877720483c5f0d38b"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlabelling_1_1Label.html#a478f34a67528586877720483c5f0d38b">weight</a> = 0.0</td></tr>
<tr class="separator:a478f34a67528586877720483c5f0d38b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c8972ee9d1c00fd348025c321467f75"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structbidirectional_1_1Vertex.html">bidirectional::Vertex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlabelling_1_1Label.html#a7c8972ee9d1c00fd348025c321467f75">vertex</a> = {-1, -1}</td></tr>
<tr class="separator:a7c8972ee9d1c00fd348025c321467f75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c185387fad46a29bce3dd99b111a1c4"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlabelling_1_1Label.html#a2c185387fad46a29bce3dd99b111a1c4">resource_consumption</a> = {}</td></tr>
<tr class="separator:a2c185387fad46a29bce3dd99b111a1c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7511d29a3aa0272b1a0e1ea5fb75ff14"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlabelling_1_1Label.html#a7511d29a3aa0272b1a0e1ea5fb75ff14">partial_path</a> = {}</td></tr>
<tr class="separator:a7511d29a3aa0272b1a0e1ea5fb75ff14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae684804e463fe690b4fe6ee32812e123"><td class="memItemLeft" align="right" valign="top">std::set&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlabelling_1_1Label.html#ae684804e463fe690b4fe6ee32812e123">unreachable_nodes</a> = {}</td></tr>
<tr class="memdesc:ae684804e463fe690b4fe6ee32812e123"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set of unreachable nodes. This is only used in the elementary case.  <a href="#ae684804e463fe690b4fe6ee32812e123">More...</a><br /></td></tr>
<tr class="separator:ae684804e463fe690b4fe6ee32812e123"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a182759fd08c2536f9e6a2614c790b127"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbidirectional_1_1Params.html">bidirectional::Params</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlabelling_1_1Label.html#a182759fd08c2536f9e6a2614c790b127">params_ptr</a> = nullptr</td></tr>
<tr class="separator:a182759fd08c2536f9e6a2614c790b127"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a632cd90937f05a8ea69ad60d4c103c66"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlabelling_1_1Label.html#a632cd90937f05a8ea69ad60d4c103c66">phi</a> = std::nan(&quot;nan&quot;)</td></tr>
<tr class="separator:a632cd90937f05a8ea69ad60d4c103c66"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:aac0781be66b1d133b633cef3f60f8183"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlabelling_1_1Label.html#aac0781be66b1d133b633cef3f60f8183">operator&lt;</a> (const <a class="el" href="classlabelling_1_1Label.html">Label</a> &amp;label1, const <a class="el" href="classlabelling_1_1Label.html">Label</a> &amp;label2)</td></tr>
<tr class="separator:aac0781be66b1d133b633cef3f60f8183"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bd46e6920cac7ede4b725f2d33fb12b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlabelling_1_1Label.html#a7bd46e6920cac7ede4b725f2d33fb12b">operator&gt;</a> (const <a class="el" href="classlabelling_1_1Label.html">Label</a> &amp;label1, const <a class="el" href="classlabelling_1_1Label.html">Label</a> &amp;label2)</td></tr>
<tr class="separator:a7bd46e6920cac7ede4b725f2d33fb12b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae52256a096ed1acaf1afaba6458b42ca"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlabelling_1_1Label.html#ae52256a096ed1acaf1afaba6458b42ca">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classlabelling_1_1Label.html">Label</a> &amp;label)</td></tr>
<tr class="separator:ae52256a096ed1acaf1afaba6458b42ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc60b45b5a5310043283c0e6c694cc92"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlabelling_1_1Label.html#abc60b45b5a5310043283c0e6c694cc92">operator==</a> (const <a class="el" href="classlabelling_1_1Label.html">Label</a> &amp;label1, const <a class="el" href="classlabelling_1_1Label.html">Label</a> &amp;label2)</td></tr>
<tr class="separator:abc60b45b5a5310043283c0e6c694cc92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48813c4c8ca8174edcdf9cf34358b442"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlabelling_1_1Label.html#a48813c4c8ca8174edcdf9cf34358b442">operator!=</a> (const <a class="el" href="classlabelling_1_1Label.html">Label</a> &amp;label1, const <a class="el" href="classlabelling_1_1Label.html">Label</a> &amp;label2)</td></tr>
<tr class="separator:a48813c4c8ca8174edcdf9cf34358b442"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Single node label. With resource, cost and other attributes.</p>
<p>Main functionality includes:</p><ul>
<li>Checking resource feasibility</li>
<li>Checking dominance </li>
</ul>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a3728b76c8b32589e04ecaac821f11733"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3728b76c8b32589e04ecaac821f11733">&#9670;&nbsp;</a></span>Label() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">labelling::Label::Label </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dummy constructor. </p>

</div>
</div>
<a id="a6861a92f1825ed3bb9ea46515cdf1d16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6861a92f1825ed3bb9ea46515cdf1d16">&#9670;&nbsp;</a></span>Label() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">labelling::Label::Label </td>
          <td>(</td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>weight_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbidirectional_1_1Vertex.html">bidirectional::Vertex</a> &amp;&#160;</td>
          <td class="paramname"><em>vertex_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>resource_consumption_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>partial_path_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbidirectional_1_1Params.html">bidirectional::Params</a> *&#160;</td>
          <td class="paramname"><em>params_ptr_in</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor. </p>
<p><a class="el" href="classlabelling_1_1Label.html">Label</a> </p>

</div>
</div>
<a id="a255f1384159b9748980f824eb1ddb5f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a255f1384159b9748980f824eb1ddb5f8">&#9670;&nbsp;</a></span>Label() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">labelling::Label::Label </td>
          <td>(</td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>weight_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbidirectional_1_1Vertex.html">bidirectional::Vertex</a> &amp;&#160;</td>
          <td class="paramname"><em>vertex_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>resource_consumption_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>partial_path_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbidirectional_1_1Params.html">bidirectional::Params</a> *&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>phi_in</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a72d8b0e24b8dbacc1ecb40b3c32265e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72d8b0e24b8dbacc1ecb40b3c32265e2">&#9670;&nbsp;</a></span>~Label()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">labelling::Label::~Label </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>default destructor </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ad5afbf2f5d2c6f208283021186783883"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5afbf2f5d2c6f208283021186783883">&#9670;&nbsp;</a></span>checkDominance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool labelling::Label::checkDominance </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlabelling_1_1Label.html">Label</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacebidirectional.html#a4cbe6f0bfbd3629c2cd44c98014aed70">bidirectional::Directions</a> &amp;&#160;</td>
          <td class="paramname"><em>direction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if this dominates other. Assumes the labels are comparable i.e. same nodes</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td><a class="el" href="classlabelling_1_1Label.html">Label</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">direction</td><td>Directions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elementary</td><td>bool, optional </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool </dd></dl>

</div>
</div>
<a id="adc3068c1147414d77f0f7696b4687e69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc3068c1147414d77f0f7696b4687e69">&#9670;&nbsp;</a></span>checkFeasibility()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool labelling::Label::checkFeasibility </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>max_res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>min_res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool &amp;&#160;</td>
          <td class="paramname"><em>soft</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check resource feasibility of current label i.e. <code>min_res[i] &lt;= resource_consumption[i] &lt;= max_res[i]</code> for <code>i</code> in <code>0,...,resource_consumption.size()</code>. If "soft" check, then the lower bound is only checked if either: resource index <code>i</code> is the index of the critical resource or <code>min_res[i]&lt;= 0</code>(See issue #90). If not "soft", then all lower bounds are checked as expected.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">max_res,vector</td><td>of double with upper bound(s) for resource consumption. Checks values are &lt;= bound </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">min_res,vector</td><td>of double with lower bound(s) for resource consumption. Checks values are &gt;= bound </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">soft,bool</td><td>with whether the minimum resources should be checked "softly". Default is false. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a496b8a76fd2fe06265b1acc1a508b4ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a496b8a76fd2fe06265b1acc1a508b4ca">&#9670;&nbsp;</a></span>checkPathExtension()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool labelling::Label::checkPathExtension </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>user_id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true is the partial path extension is OK. </p>

</div>
</div>
<a id="a02179d540444a13aa7cc3355d0a461b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02179d540444a13aa7cc3355d0a461b8">&#9670;&nbsp;</a></span>checkSameFeasibleExtension()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool labelling::Label::checkSameFeasibleExtension </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlabelling_1_1Label.html">Label</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if both lables have the same feasible extension, i.e., if they both can extend to the same nodes. Important for correct dominance check. Labels with different feasible extension cannot dominate each other. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other,<a class="el" href="classlabelling_1_1Label.html">Label</a></td><td>with other label to compare </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if this and other have same feasible extension </dd></dl>

</div>
</div>
<a id="a333b6fc9dba864b3df2cdf530a055aa7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a333b6fc9dba864b3df2cdf530a055aa7">&#9670;&nbsp;</a></span>checkSameFeasibleExtensionElementary()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool labelling::Label::checkSameFeasibleExtensionElementary </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlabelling_1_1Label.html">Label</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Simple check if both lables have the same feasible extension under elementary conditions. this and other have the same feasible extension if unreachable_nodes of this is subset of unreachable_nodes of other </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other,<a class="el" href="classlabelling_1_1Label.html">Label</a></td><td>with other label to compare </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if this and other have same feasible extension </dd></dl>

</div>
</div>
<a id="a5c8dc87a89577d00ccf86251867ec76a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c8dc87a89577d00ccf86251867ec76a">&#9670;&nbsp;</a></span>checkSameFeasibleExtensionTwoCycleSimple()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool labelling::Label::checkSameFeasibleExtensionTwoCycleSimple </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlabelling_1_1Label.html">Label</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Simple check if both lables have the same feasible extension with regard to 2-cycle elimination. this and other have same feasible extension if predecessor is the same. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other,<a class="el" href="classlabelling_1_1Label.html">Label</a></td><td>with other label to compare </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if this and other have same feasible extension </dd></dl>

</div>
</div>
<a id="a0e4957ff69cf08cfdc743df10d50d3c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e4957ff69cf08cfdc743df10d50d3c7">&#9670;&nbsp;</a></span>checkStPath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool labelling::Label::checkStPath </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>source_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>sink_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check whether the current partial path is Source - Sink</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">source_id,int</td><td>with user_id of the source node. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sink_id,int</td><td>with user_id of the sink node. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a72d0d91c2d99edbcdc36aa157586cf00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72d0d91c2d99edbcdc36aa157586cf00">&#9670;&nbsp;</a></span>checkThreshold()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool labelling::Label::checkThreshold </td>
          <td>(</td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>threshold</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if weight is under the input threshold. </p>

</div>
</div>
<a id="a23f7e5da2fb22dca07977aad9bfa9ad3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23f7e5da2fb22dca07977aad9bfa9ad3">&#9670;&nbsp;</a></span>extend()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlabelling_1_1Label.html">Label</a> labelling::Label::extend </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbidirectional_1_1AdjVertex.html">bidirectional::AdjVertex</a> &amp;&#160;</td>
          <td class="paramname"><em>adjacent_vertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacebidirectional.html#a4cbe6f0bfbd3629c2cd44c98014aed70">bidirectional::Directions</a> &amp;&#160;</td>
          <td class="paramname"><em>direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>max_res</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>min_res</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generate new label extensions from the current label and return only if resource feasible. The input label is a pointer as it may be modified in the case that the edge / adjacent_vertex is found to be resource infeasible, in which case, the head/tail node becomes unreachable and the attribute is updated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">label,<a class="el" href="classlabelling_1_1Label.html">labelling::Label</a>,current</td><td>label to extend (and maybe update <code>unreachable_nodes</code>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">adjacent_vertex,AdjVertex,edge</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">direction</td><td>Directions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elementary</td><td>bool </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_res,vector</td><td>of double with upper bound(s) for resource consumption </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">min_res,vector</td><td>of double with lower bound(s) for resource consumption</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classlabelling_1_1Label.html">Label</a> object with extended label. Note this may be empty if the extension is resource infeasible </dd></dl>

</div>
</div>
<a id="a3f59b4a2818a4b0096080cd5f830b73d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f59b4a2818a4b0096080cd5f830b73d">&#9670;&nbsp;</a></span>fullDominance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool labelling::Label::fullDominance </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlabelling_1_1Label.html">Label</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacebidirectional.html#a4cbe6f0bfbd3629c2cd44c98014aed70">bidirectional::Directions</a> &amp;&#160;</td>
          <td class="paramname"><em>direction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks whether <code>this</code> dominates <code>other</code> for the input direction. In the case when neither dominates , i.e. they are non-dominated, the direction is flipped labels are compared again.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td><a class="el" href="classlabelling_1_1Label.html">Label</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">direction</td><td>Directions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elementary</td><td>bool </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool </dd></dl>

</div>
</div>
<a id="a676337cc2e66ddaba088c736b9220651"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a676337cc2e66ddaba088c736b9220651">&#9670;&nbsp;</a></span>getPredecessorId()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int labelling::Label::getPredecessorId </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>gets the id of the predecessor node TODO can be replaced as member of label </p>

</div>
</div>
<a id="adc93c3a59a853bc559bb63e8df1ae67e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc93c3a59a853bc559bb63e8df1ae67e">&#9670;&nbsp;</a></span>getString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string labelling::Label::getString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a96fec70e1378988bb3d01f3aee8ab676"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96fec70e1378988bb3d01f3aee8ab676">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlabelling_1_1Label.html">Label</a>&amp; labelling::Label::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlabelling_1_1Label.html">Label</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afffea46e29dc7074edd10470c5dfeb87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afffea46e29dc7074edd10470c5dfeb87">&#9670;&nbsp;</a></span>setPhi()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void labelling::Label::setPhi </td>
          <td>(</td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>phi_in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>set phi attribute for merged labels from Righini and Salani (2006) </p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a48813c4c8ca8174edcdf9cf34358b442"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48813c4c8ca8174edcdf9cf34358b442">&#9670;&nbsp;</a></span>operator!=</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlabelling_1_1Label.html">Label</a> &amp;&#160;</td>
          <td class="paramname"><em>label1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlabelling_1_1Label.html">Label</a> &amp;&#160;</td>
          <td class="paramname"><em>label2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aac0781be66b1d133b633cef3f60f8183"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac0781be66b1d133b633cef3f60f8183">&#9670;&nbsp;</a></span>operator<</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlabelling_1_1Label.html">Label</a> &amp;&#160;</td>
          <td class="paramname"><em>label1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlabelling_1_1Label.html">Label</a> &amp;&#160;</td>
          <td class="paramname"><em>label2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae52256a096ed1acaf1afaba6458b42ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae52256a096ed1acaf1afaba6458b42ca">&#9670;&nbsp;</a></span>operator<<</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlabelling_1_1Label.html">Label</a> &amp;&#160;</td>
          <td class="paramname"><em>label</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="abc60b45b5a5310043283c0e6c694cc92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc60b45b5a5310043283c0e6c694cc92">&#9670;&nbsp;</a></span>operator==</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlabelling_1_1Label.html">Label</a> &amp;&#160;</td>
          <td class="paramname"><em>label1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlabelling_1_1Label.html">Label</a> &amp;&#160;</td>
          <td class="paramname"><em>label2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Check every resource for inequality </p>

</div>
</div>
<a id="a7bd46e6920cac7ede4b725f2d33fb12b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bd46e6920cac7ede4b725f2d33fb12b">&#9670;&nbsp;</a></span>operator></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlabelling_1_1Label.html">Label</a> &amp;&#160;</td>
          <td class="paramname"><em>label1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlabelling_1_1Label.html">Label</a> &amp;&#160;</td>
          <td class="paramname"><em>label2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a182759fd08c2536f9e6a2614c790b127"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a182759fd08c2536f9e6a2614c790b127">&#9670;&nbsp;</a></span>params_ptr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbidirectional_1_1Params.html">bidirectional::Params</a>* labelling::Label::params_ptr = nullptr</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7511d29a3aa0272b1a0e1ea5fb75ff14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7511d29a3aa0272b1a0e1ea5fb75ff14">&#9670;&nbsp;</a></span>partial_path</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;int&gt; labelling::Label::partial_path = {}</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a632cd90937f05a8ea69ad60d4c103c66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a632cd90937f05a8ea69ad60d4c103c66">&#9670;&nbsp;</a></span>phi</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double labelling::Label::phi = std::nan(&quot;nan&quot;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2c185387fad46a29bce3dd99b111a1c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c185387fad46a29bce3dd99b111a1c4">&#9670;&nbsp;</a></span>resource_consumption</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;double&gt; labelling::Label::resource_consumption = {}</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae684804e463fe690b4fe6ee32812e123"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae684804e463fe690b4fe6ee32812e123">&#9670;&nbsp;</a></span>unreachable_nodes</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::set&lt;int&gt; labelling::Label::unreachable_nodes = {}</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set of unreachable nodes. This is only used in the elementary case. </p>

</div>
</div>
<a id="a7c8972ee9d1c00fd348025c321467f75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c8972ee9d1c00fd348025c321467f75">&#9670;&nbsp;</a></span>vertex</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbidirectional_1_1Vertex.html">bidirectional::Vertex</a> labelling::Label::vertex = {-1, -1}</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a478f34a67528586877720483c5f0d38b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a478f34a67528586877720483c5f0d38b">&#9670;&nbsp;</a></span>weight</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double labelling::Label::weight = 0.0</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/__w/cspy/cspy/torressa/cspy/src/cc/<a class="el" href="labelling_8h_source.html">labelling.h</a></li>
<li>/__w/cspy/cspy/torressa/cspy/src/cc/<a class="el" href="labelling_8cc.html">labelling.cc</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
