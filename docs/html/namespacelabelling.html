<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>cspy: labelling Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">cspy
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">labelling Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlabelling_1_1Label.html">Label</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a96ce48b2672548c132a1032820202375"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelabelling.html#a96ce48b2672548c132a1032820202375">operator==</a> (const <a class="el" href="classlabelling_1_1Label.html">Label</a> &amp;label1, const <a class="el" href="classlabelling_1_1Label.html">Label</a> &amp;label2)</td></tr>
<tr class="separator:a96ce48b2672548c132a1032820202375"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71cfecc2e31a39a8743e584c12b3fd32"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelabelling.html#a71cfecc2e31a39a8743e584c12b3fd32">operator&lt;</a> (const <a class="el" href="classlabelling_1_1Label.html">Label</a> &amp;label1, const <a class="el" href="classlabelling_1_1Label.html">Label</a> &amp;label2)</td></tr>
<tr class="separator:a71cfecc2e31a39a8743e584c12b3fd32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a079cd7339d7a3797d35ebbd5b4e930f6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelabelling.html#a079cd7339d7a3797d35ebbd5b4e930f6">operator&gt;</a> (const <a class="el" href="classlabelling_1_1Label.html">Label</a> &amp;label1, const <a class="el" href="classlabelling_1_1Label.html">Label</a> &amp;label2)</td></tr>
<tr class="separator:a079cd7339d7a3797d35ebbd5b4e930f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac988eedb6084b429a46b070f3ff6d544"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelabelling.html#ac988eedb6084b429a46b070f3ff6d544">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classlabelling_1_1Label.html">Label</a> &amp;label)</td></tr>
<tr class="separator:ac988eedb6084b429a46b070f3ff6d544"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6d6bb89c176d0f2db264457d60c5bd8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelabelling.html#ac6d6bb89c176d0f2db264457d60c5bd8">runDominanceEff</a> (std::vector&lt; <a class="el" href="classlabelling_1_1Label.html">Label</a> &gt; *efficient_labels_ptr, const <a class="el" href="classlabelling_1_1Label.html">Label</a> &amp;label, const <a class="el" href="namespacebidirectional.html#a4cbe6f0bfbd3629c2cd44c98014aed70">bidirectional::Directions</a> &amp;direction, const bool &amp;elementary)</td></tr>
<tr class="separator:ac6d6bb89c176d0f2db264457d60c5bd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d32365acb745f452e0b81beed2ce2be"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlabelling_1_1Label.html">Label</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelabelling.html#a7d32365acb745f452e0b81beed2ce2be">getNextLabel</a> (std::vector&lt; <a class="el" href="classlabelling_1_1Label.html">Label</a> &gt; *labels_ptr, const <a class="el" href="namespacebidirectional.html#a4cbe6f0bfbd3629c2cd44c98014aed70">bidirectional::Directions</a> &amp;direction)</td></tr>
<tr class="separator:a7d32365acb745f452e0b81beed2ce2be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae172758fb8d07cc0a490d8715966e1b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlabelling_1_1Label.html">Label</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelabelling.html#ae172758fb8d07cc0a490d8715966e1b7">processBwdLabel</a> (const <a class="el" href="classlabelling_1_1Label.html">labelling::Label</a> &amp;label, const std::vector&lt; double &gt; &amp;max_res, const std::vector&lt; double &gt; &amp;cumulative_resource, const bool &amp;invert_min_res)</td></tr>
<tr class="separator:ae172758fb8d07cc0a490d8715966e1b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bb0d5a3d1eeb92546902c6cdc12c71d"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelabelling.html#a5bb0d5a3d1eeb92546902c6cdc12c71d">getPhiValue</a> (const <a class="el" href="classlabelling_1_1Label.html">labelling::Label</a> &amp;fwd_label, const <a class="el" href="classlabelling_1_1Label.html">labelling::Label</a> &amp;bwd_label, const std::vector&lt; double &gt; &amp;max_res)</td></tr>
<tr class="separator:a5bb0d5a3d1eeb92546902c6cdc12c71d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7fee591bcb066e39ff97138ab0ba5ca"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelabelling.html#ad7fee591bcb066e39ff97138ab0ba5ca">halfwayCheck</a> (const <a class="el" href="classlabelling_1_1Label.html">Label</a> &amp;label, const std::vector&lt; <a class="el" href="classlabelling_1_1Label.html">Label</a> &gt; &amp;labels)</td></tr>
<tr class="separator:ad7fee591bcb066e39ff97138ab0ba5ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c2e8f16965144d445ba68216dae648f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelabelling.html#a9c2e8f16965144d445ba68216dae648f">mergePreCheck</a> (const <a class="el" href="classlabelling_1_1Label.html">labelling::Label</a> &amp;fwd_label, const <a class="el" href="classlabelling_1_1Label.html">labelling::Label</a> &amp;bwd_label, const std::vector&lt; double &gt; &amp;max_res)</td></tr>
<tr class="separator:a9c2e8f16965144d445ba68216dae648f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19937349c6ec5c31d5994aac45c5d2fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlabelling_1_1Label.html">Label</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelabelling.html#a19937349c6ec5c31d5994aac45c5d2fd">mergeLabels</a> (const <a class="el" href="classlabelling_1_1Label.html">Label</a> &amp;fwd_label, const <a class="el" href="classlabelling_1_1Label.html">Label</a> &amp;bwd_label, const <a class="el" href="structbidirectional_1_1AdjVertex.html">bidirectional::AdjVertex</a> &amp;adj_vertex, const <a class="el" href="structbidirectional_1_1Vertex.html">bidirectional::Vertex</a> &amp;sink, const std::vector&lt; double &gt; &amp;max_res, const std::vector&lt; double &gt; &amp;min_res)</td></tr>
<tr class="separator:a19937349c6ec5c31d5994aac45c5d2fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="a7d32365acb745f452e0b81beed2ce2be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d32365acb745f452e0b81beed2ce2be">&#9670;&nbsp;</a></span>getNextLabel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlabelling_1_1Label.html">Label</a> labelling::getNextLabel </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classlabelling_1_1Label.html">Label</a> &gt; *&#160;</td>
          <td class="paramname"><em>labels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacebidirectional.html#a4cbe6f0bfbd3629c2cd44c98014aed70">bidirectional::Directions</a> &amp;&#160;</td>
          <td class="paramname"><em>direction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get next label from ordered labels Grabs the next element in the heap (back) and removes it In the forward (backward) direction this is the label with lowest (highest) monotone resource.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">labels,std::vector&lt;Label&gt;</td><td>pointer (heap) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">direction,Directions</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5bb0d5a3d1eeb92546902c6cdc12c71d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bb0d5a3d1eeb92546902c6cdc12c71d">&#9670;&nbsp;</a></span>getPhiValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double labelling::getPhiValue </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlabelling_1_1Label.html">labelling::Label</a> &amp;&#160;</td>
          <td class="paramname"><em>fwd_label</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlabelling_1_1Label.html">labelling::Label</a> &amp;&#160;</td>
          <td class="paramname"><em>bwd_label</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>max_res</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the phi value. As defined in Righini and Salani (2006) </p>

</div>
</div>
<a id="ad7fee591bcb066e39ff97138ab0ba5ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7fee591bcb066e39ff97138ab0ba5ca">&#9670;&nbsp;</a></span>halfwayCheck()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool labelling::halfwayCheck </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlabelling_1_1Label.html">Label</a> &amp;&#160;</td>
          <td class="paramname"><em>label</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classlabelling_1_1Label.html">Label</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>labels</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check whether the pair (phi, path) is already contained in all the (phi, path) pairs with a lower phi.</p>
<p>As defined in Righini and Salani (2006) </p>

</div>
</div>
<a id="a19937349c6ec5c31d5994aac45c5d2fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19937349c6ec5c31d5994aac45c5d2fd">&#9670;&nbsp;</a></span>mergeLabels()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlabelling_1_1Label.html">Label</a> labelling::mergeLabels </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlabelling_1_1Label.html">labelling::Label</a> &amp;&#160;</td>
          <td class="paramname"><em>fwd_label</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlabelling_1_1Label.html">labelling::Label</a> &amp;&#160;</td>
          <td class="paramname"><em>bwd_label</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbidirectional_1_1AdjVertex.html">bidirectional::AdjVertex</a> &amp;&#160;</td>
          <td class="paramname"><em>adj_vertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbidirectional_1_1Vertex.html">bidirectional::Vertex</a> &amp;&#160;</td>
          <td class="paramname"><em>sink</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>max_res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>min_res</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Merge labels produced by a backward and forward label. If an s-t compatible path can be obtained the appropriately extended and merged label is returned.</p>
<dl class="section return"><dt>Returns</dt><dd>merged label with updated attributes and new phi value. </dd></dl>

</div>
</div>
<a id="a9c2e8f16965144d445ba68216dae648f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c2e8f16965144d445ba68216dae648f">&#9670;&nbsp;</a></span>mergePreCheck()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool labelling::mergePreCheck </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlabelling_1_1Label.html">labelling::Label</a> &amp;&#160;</td>
          <td class="paramname"><em>fwd_label</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlabelling_1_1Label.html">labelling::Label</a> &amp;&#160;</td>
          <td class="paramname"><em>bwd_label</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>max_res</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check whether a pair of forward and backward labels are suitable for merging. To be used before attempting to merge. </p>

</div>
</div>
<a id="a71cfecc2e31a39a8743e584c12b3fd32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71cfecc2e31a39a8743e584c12b3fd32">&#9670;&nbsp;</a></span>operator<()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool labelling::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlabelling_1_1Label.html">Label</a> &amp;&#160;</td>
          <td class="paramname"><em>label1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlabelling_1_1Label.html">Label</a> &amp;&#160;</td>
          <td class="paramname"><em>label2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac988eedb6084b429a46b070f3ff6d544"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac988eedb6084b429a46b070f3ff6d544">&#9670;&nbsp;</a></span>operator<<()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; labelling::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlabelling_1_1Label.html">Label</a> &amp;&#160;</td>
          <td class="paramname"><em>label</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a96ce48b2672548c132a1032820202375"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96ce48b2672548c132a1032820202375">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool labelling::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlabelling_1_1Label.html">Label</a> &amp;&#160;</td>
          <td class="paramname"><em>label1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlabelling_1_1Label.html">Label</a> &amp;&#160;</td>
          <td class="paramname"><em>label2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check every resource for inequality </p>

</div>
</div>
<a id="a079cd7339d7a3797d35ebbd5b4e930f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a079cd7339d7a3797d35ebbd5b4e930f6">&#9670;&nbsp;</a></span>operator>()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool labelling::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlabelling_1_1Label.html">Label</a> &amp;&#160;</td>
          <td class="paramname"><em>label1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlabelling_1_1Label.html">Label</a> &amp;&#160;</td>
          <td class="paramname"><em>label2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae172758fb8d07cc0a490d8715966e1b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae172758fb8d07cc0a490d8715966e1b7">&#9670;&nbsp;</a></span>processBwdLabel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlabelling_1_1Label.html">Label</a> labelling::processBwdLabel </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlabelling_1_1Label.html">labelling::Label</a> &amp;&#160;</td>
          <td class="paramname"><em>label</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>max_res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>cumulative_resource</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool &amp;&#160;</td>
          <td class="paramname"><em>invert_min_res</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reverse backward path and inverts resource consumption and returns resulting forward-compatible label.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">label,<a class="el" href="classlabelling_1_1Label.html">labelling::Label</a>,current</td><td>label to extend (and maybe update <code>unreachable_nodes</code>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_res,vector</td><td>of double with upper bound(s) for resource consumption. To use to invert monotone resource </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">invert_min_res,bool</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>inverted label </dd></dl>

</div>
</div>
<a id="ac6d6bb89c176d0f2db264457d60c5bd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6d6bb89c176d0f2db264457d60c5bd8">&#9670;&nbsp;</a></span>runDominanceEff()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool labelling::runDominanceEff </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classlabelling_1_1Label.html">Label</a> &gt; *&#160;</td>
          <td class="paramname"><em>efficient_labels_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlabelling_1_1Label.html">Label</a> &amp;&#160;</td>
          <td class="paramname"><em>label</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacebidirectional.html#a4cbe6f0bfbd3629c2cd44c98014aed70">bidirectional::Directions</a> &amp;&#160;</td>
          <td class="paramname"><em>direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool &amp;&#160;</td>
          <td class="paramname"><em>elementary</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Misc functionality</p>
<p>Check whether the input label dominates any efficient label (previously undominated labels) at the same node. If any label is dominated by the input label, they are removed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">efficient_labels,pointer</td><td>to a vector of <a class="el" href="classlabelling_1_1Label.html">Label</a> with the efficient labels at the same node as <code>label</code>. If a label is dominated by <code>label</code>, it is removed from this vector. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">label,<a class="el" href="classlabelling_1_1Label.html">Label</a></td><td>to compare </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">direction,Directions</td><td>with direction of search </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elementary,bool</td><td>with whether non-elementary paths are allowed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool, true if <code>label</code> is dominated, false otherwise </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
